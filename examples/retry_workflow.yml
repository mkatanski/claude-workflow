# Retry Tool Example
# Demonstrates retry operations with backoff, conditions, and error handling
# Use retry for transient failures, flaky operations, self-healing workflows

type: claude-workflow
version: 2
name: "Retry Tool Demo"
description: "Showcase retry tool with all options: max_attempts, delay, until, on_failure"

steps:
  # ============================================================
  # BASIC: Simple retry with fixed attempts
  # ============================================================
  - name: "Basic retry (max 3 attempts)"
    tool: retry
    max_attempts: 3
    steps:
      - name: "Try operation"
        tool: bash
        command: |
          echo "Attempt #{_attempt} of 3"
          # Simulate: succeed on attempt 2
          if [ {_attempt} -eq 2 ]; then
            echo "success"
            exit 0
          else
            echo "failed"
            exit 1
          fi

  - name: "Show retry result"
    tool: bash
    command: "echo 'Retry succeeded: {_retry_succeeded}, Total attempts: {_retry_attempts}'"

  # ============================================================
  # DELAY: Add delay between retries
  # ============================================================
  - name: "Retry with delay"
    tool: retry
    max_attempts: 3
    delay: 2
    steps:
      - name: "API call with delay"
        tool: bash
        command: |
          echo "[$(date +%H:%M:%S)] Attempt {_attempt}: Calling API..."
          # Simulate: succeed on attempt 2
          if [ {_attempt} -ge 2 ]; then
            echo "success"
          else
            echo "failed"
            exit 1
          fi

  # ============================================================
  # UNTIL: Success condition based on output
  # ============================================================
  - name: "Initialize result variable"
    tool: set
    var: api_result
    value: "pending"

  - name: "Retry until condition met"
    tool: retry
    max_attempts: 5
    delay: 1
    until: "{api_result} == success"
    steps:
      - name: "Check status"
        tool: bash
        command: |
          echo "Checking... (attempt {_attempt})"
          # Simulate: returns success on attempt 3
          if [ {_attempt} -ge 3 ]; then
            echo "success"
          else
            echo "pending"
          fi
        output_var: api_result

  - name: "Show until result"
    tool: bash
    command: "echo 'Result: {api_result} after {_retry_attempts} attempts'"

  # ============================================================
  # ON_FAILURE: Continue workflow even if all retries fail
  # ============================================================
  - name: "Retry with on_failure: continue"
    tool: retry
    max_attempts: 2
    on_failure: continue
    steps:
      - name: "Always failing operation"
        tool: bash
        command: |
          echo "Attempt {_attempt}: This will always fail"
          exit 1

  - name: "Workflow continues after retry failure"
    tool: bash
    command: "echo 'Retry failed but workflow continues: succeeded={_retry_succeeded}'"

  # ============================================================
  # PRACTICAL: Self-healing test runner
  # ============================================================
  - name: "Initialize test state"
    tool: set
    var: test_exit_code
    value: "1"

  - name: "Run tests with auto-fix"
    tool: retry
    max_attempts: 3
    until: "{test_exit_code} == 0"
    steps:
      - name: "Run test suite"
        tool: bash
        command: |
          echo "Running tests... (attempt {_attempt})"
          # Simulate: tests pass on attempt 3 (after fixes)
          if [ {_attempt} -ge 3 ]; then
            echo "All tests passed!"
            echo "0"
          else
            echo "2 tests failed"
            echo "1"
          fi
        output_var: test_exit_code

      - name: "Fix failing tests"
        prompt: |
          The test suite failed on attempt {_attempt}.
          Exit code: {test_exit_code}

          Analyze the test output and fix the failing tests.
          This is a simulated fix for demonstration.
        when: "{test_exit_code} != 0"

  - name: "Test results"
    tool: bash
    command: "echo 'Tests: exit_code={test_exit_code}, attempts={_retry_attempts}'"

  # ============================================================
  # PRACTICAL: API with exponential backoff simulation
  # ============================================================
  - name: "Initialize backoff state"
    tool: set
    var: api_response
    value: "rate_limited"

  - name: "API call with retry"
    tool: retry
    max_attempts: 4
    delay: 2
    until: "{api_response} == ok"
    steps:
      - name: "Call external API"
        tool: bash
        command: |
          echo "API request attempt {_attempt}"
          # Simulate: rate limited initially, succeeds on attempt 3
          if [ {_attempt} -ge 3 ]; then
            echo "ok"
          else
            echo "rate_limited"
          fi
        output_var: api_response

      - name: "Log rate limit"
        tool: bash
        command: "echo 'Rate limited, backing off...'"
        when: "{api_response} == rate_limited"

  # ============================================================
  # PRACTICAL: Database connection retry
  # ============================================================
  - name: "Initialize DB connection state"
    tool: set
    var: db_connected
    value: "false"

  - name: "Connect to database"
    tool: retry
    max_attempts: 5
    delay: 3
    until: "{db_connected} == true"
    on_failure: continue
    steps:
      - name: "Attempt DB connection"
        tool: bash
        command: |
          echo "Connecting to database... (attempt {_attempt})"
          # Simulate: connection succeeds on attempt 4
          if [ {_attempt} -ge 4 ]; then
            echo "true"
          else
            echo "false"
          fi
        output_var: db_connected

  - name: "DB connection result"
    tool: bash
    command: |
      if [ "{db_connected}" = "true" ]; then
        echo "Database connected successfully after {_retry_attempts} attempts"
      else
        echo "Database connection failed after {_retry_attempts} attempts"
      fi

  # ============================================================
  # COMPLEX: Nested retry with multiple conditions
  # ============================================================
  - name: "Initialize multi-step state"
    tool: context
    action: set
    values:
      build_success: "false"
      deploy_success: "false"

  - name: "Build and deploy with retries"
    tool: retry
    max_attempts: 2
    until: "{build_success} == true and {deploy_success} == true"
    steps:
      - name: "Build project"
        tool: bash
        command: |
          echo "Building project... (attempt {_attempt})"
          echo "true"
        output_var: build_success

      - name: "Deploy if build succeeded"
        tool: bash
        command: |
          echo "Deploying... (attempt {_attempt})"
          # Simulate: deploy succeeds on second attempt
          if [ {_attempt} -ge 2 ]; then
            echo "true"
          else
            echo "false"
          fi
        output_var: deploy_success
        when: "{build_success} == true"

  - name: "Final deployment status"
    tool: bash
    command: |
      echo "Build: {build_success}, Deploy: {deploy_success}"
      echo "Completed in {_retry_attempts} attempts"

  - name: "Retry demo complete"
    tool: bash
    command: "echo 'All retry examples completed!'"
