# Claude Multi-Model Workflow
# Demonstrates: Using different models for different tasks
# Use case: Cost optimization - use cheaper models for simple tasks, powerful for complex

type: claude-workflow
version: 2

name: "Claude Multi-Model Workflow"

claude:
  interactive: true
  model: sonnet
  dangerously_skip_permissions: true

tmux:
  split: vertical
  idle_time: 5.0

steps:
  # ===========================================
  # Setup: Get some code to analyze
  # ===========================================

  - name: "Get sample code"
    tool: bash
    command: |
      cat << 'EOF'
      def calculate_total(items):
          total = 0
          for item in items:
              total += item.price * item.quantity
          return total

      class Item:
          def __init__(self, name, price, quantity):
              self.name = name
              self.price = price
              self.quantity = quantity
      EOF
    output_var: sample_code

  # ===========================================
  # Quick analysis with Haiku (fast, cheap)
  # ===========================================

  - name: "Quick review with Haiku"
    prompt: |
      Briefly describe what this code does in one sentence:

      {sample_code}
    model: haiku
    output_var: haiku_summary

  - name: "Report Haiku result"
    tool: bash
    command: "echo 'Haiku summary complete'"

  # ===========================================
  # Detailed analysis with Sonnet (balanced)
  # ===========================================

  - name: "Detailed review with Sonnet"
    prompt: |
      Review this code and identify:
      1. What it does
      2. Any potential issues
      3. Suggestions for improvement

      {sample_code}
    model: sonnet
    output_var: sonnet_review

  - name: "Report Sonnet result"
    tool: bash
    command: "echo 'Sonnet review complete'"

  # ===========================================
  # Deep analysis with Opus (most capable)
  # ===========================================

  - name: "Deep analysis with Opus"
    prompt: |
      Perform a comprehensive code review:

      {sample_code}

      Include:
      - Architectural analysis
      - Performance considerations
      - Security implications
      - Type safety assessment
      - Test coverage recommendations
      - Alternative design patterns
    model: opus
    output_var: opus_analysis

  - name: "Report Opus result"
    tool: bash
    command: "echo 'Opus analysis complete'"

  # ===========================================
  # Practical pattern: Triage then deep dive
  # ===========================================

  - name: "Get more code"
    tool: bash
    command: |
      cat << 'EOF'
      async function fetchUserData(userId) {
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        return data;
      }
      EOF
    output_var: js_code

  # Use Haiku to quickly decide if code needs review
  - name: "Quick triage with Haiku"
    prompt: |
      Does this code have any obvious issues that need attention? Just answer yes or no.

      {js_code}
    model: haiku
    output_var: needs_review

  # Only do deep review if Haiku flagged issues
  - name: "Conditional deep review"
    prompt: |
      This code was flagged for review. Please provide detailed feedback:

      {js_code}

      Focus on:
      - Error handling
      - Security
      - Best practices
    model: sonnet
    when: "{needs_review} contains yes"
    output_var: conditional_review

  # ===========================================
  # Summary
  # ===========================================

  - name: "Workflow complete"
    tool: bash
    command: "echo 'Multi-model workflow complete. Used Haiku for quick checks, Sonnet for balanced review, Opus for deep analysis.'"
    output_var: done
